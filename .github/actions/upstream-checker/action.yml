name: 'Upstream Dependency Checker'
description: 'Checks for updates in upstream repositories and optionally commits changes to a state file.'

inputs:
  repositories:
    description: 'JSON array of repository objects: [{"repo": "owner/repo", "check_type": "release|prerelease|commit"}]. check_type is optional (defaults to auto: release ‚Üí prerelease ‚Üí commit).'
    required: true
  state_file:
    description: 'Path to file storing versions (format: "owner/repo sha tag_name check_type"). If empty, only outputs results without committing.'
    required: false
    default: ''
  token:
    description: 'GitHub token for API access. Optional for public repos but recommended to avoid rate limits. Required for private repositories.'
    required: false
    default: ''

outputs:
  results:
    description: 'JSON array of results: [{"repo": "owner/repo", "sha": "abc123...", "tag": "v1.0.0", "check_type": "release", "is_updated": true}]'
    value: ${{ steps.check_updates.outputs.results }}
  has_updates:
    description: 'Boolean string ("true"/"false") indicating if any updates were found compared to state_file.'
    value: ${{ steps.check_updates.outputs.has_updates }}

runs:
  using: "composite"
  steps:
    - name: 'Check for updates'
      id: check_updates
      shell: bash
      run: |
        set -e
        
        STATE_FILE="${{ inputs.state_file }}"
        UPSTREAM_REPOS='${{ inputs.repositories }}'
        TOKEN="${{ inputs.token }}"
        
        # Validate JSON input
        if ! echo "$UPSTREAM_REPOS" | jq empty 2>/dev/null; then
          echo "‚ùå Error: repositories must be valid JSON array"
          echo "   Example: [{"\"repo\"": "\"owner/repo\"", "\"check_type\"": "\"release\""}]"
          exit 1
        fi
        
        # Helper function for curl with optional auth
        curl_api() {
          local url="$1"
          if [[ -n "$TOKEN" ]]; then
            curl -s -L \
              -H "Accept: application/vnd.github.v3+json" \
              -H "Authorization: Bearer $TOKEN" \
              "$url"
          else
            curl -s -L \
              -H "Accept: application/vnd.github.v3+json" \
              "$url"
          fi
        }
        
        # Read current state from file
        declare -A current_shas
        declare -A current_tags
        declare -A current_check_types
        if [[ -n "$STATE_FILE" && -f "$STATE_FILE" ]]; then
          echo "üìñ Reading existing state from $STATE_FILE"
          while IFS=' ' read -r repo sha tag check_type || [[ -n "$repo" ]]; do
            # Skip empty lines and comments
            [[ -z "$repo" || "$repo" =~ ^# ]] && continue
            current_shas["$repo"]="$sha"
            current_tags["$repo"]="${tag:--}"
            current_check_types["$repo"]="${check_type:-release}"
          done < "$STATE_FILE"
        fi
        
        # Main checking loop
        echo ""
        echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        echo "üîç Checking upstream repositories"
        echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        
        has_changed=false
        commit_body=""
        declare -A new_shas
        declare -A new_tags
        declare -A new_check_types
        results_json="["
        first_result=true
        
        repo_count=$(echo "$UPSTREAM_REPOS" | jq '. | length')
        
        for ((i=0; i<repo_count; i++)); do
          repo=$(echo "$UPSTREAM_REPOS" | jq -r ".[$i].repo")
          requested_check_type=$(echo "$UPSTREAM_REPOS" | jq -r ".[$i].check_type // \"auto\"")
          
          [[ -z "$repo" || "$repo" == "null" ]] && continue
          
          echo ""
          echo "üì¶ Checking $repo"
          
          latest_sha=""
          tag_name=""
          actual_check_type=""
          
          # Function to try getting release
          try_release() {
            local release_data=$(curl_api "https://api.github.com/repos/$repo/releases/latest")
            local tag=$(echo "$release_data" | jq -r 'select(.tag_name != null) | .tag_name')
            if [[ -n "$tag" && "$tag" != "null" ]]; then
              echo "$tag"
              return 0
            fi
            return 1
          }
          
          # Function to try getting prerelease
          try_prerelease() {
            local releases_data=$(curl_api "https://api.github.com/repos/$repo/releases?per_page=1")
            local tag=$(echo "$releases_data" | jq -r 'select(length > 0) | .[0].tag_name')
            if [[ -n "$tag" && "$tag" != "null" ]]; then
              echo "$tag"
              return 0
            fi
            return 1
          }
          
          # Function to try getting commit
          try_commit() {
            local commits_data=$(curl_api "https://api.github.com/repos/$repo/commits?per_page=1")
            local sha=$(echo "$commits_data" | jq -r 'select(length > 0) | .[0].sha')
            if [[ -n "$sha" && "$sha" != "null" ]]; then
              echo "$sha"
              return 0
            fi
            return 1
          }
          
          # Determine what to check based on requested_check_type
          if [[ "$requested_check_type" == "auto" ]]; then
            echo "   Mode: Auto (release ‚Üí prerelease ‚Üí commit)"
            
            # Try release first
            if tag_name=$(try_release); then
              actual_check_type="release"
              echo "   ‚úì Found stable release: $tag_name"
            elif tag_name=$(try_prerelease); then
              actual_check_type="prerelease"
              echo "   ‚úì Found prerelease: $tag_name"
            elif latest_sha=$(try_commit); then
              actual_check_type="commit"
              tag_name="-"
              echo "   ‚úì Using latest commit"
            else
              echo "   ‚ö†Ô∏è  Could not fetch any version, skipping"
              continue
            fi
          else
            # Validate requested check type
            if [[ ! "$requested_check_type" =~ ^(release|prerelease|commit)$ ]]; then
              echo "   ‚ö†Ô∏è  Invalid check_type '$requested_check_type', skipping"
              continue
            fi
            
            actual_check_type="$requested_check_type"
            
            case "$requested_check_type" in
              release)
                echo "   Mode: Latest stable release (excluding pre-releases)"
                if tag_name=$(try_release); then
                  echo "   ‚úì Found release: $tag_name"
                else
                  echo "   ‚ö†Ô∏è  No stable release found, skipping"
                  continue
                fi
                ;;
                
              prerelease)
                echo "   Mode: Latest release (including pre-releases)"
                if tag_name=$(try_prerelease); then
                  echo "   ‚úì Found release: $tag_name"
                else
                  echo "   ‚ö†Ô∏è  No releases found, skipping"
                  continue
                fi
                ;;
                
              commit)
                echo "   Mode: Latest commit on default branch"
                if latest_sha=$(try_commit); then
                  tag_name="-"
                  echo "   ‚úì Found commit"
                else
                  echo "   ‚ö†Ô∏è  Could not fetch latest commit, skipping"
                  continue
                fi
                ;;
            esac
          fi
          
          # For release/prerelease modes, resolve tag to commit SHA
          if [[ "$actual_check_type" != "commit" && -n "$tag_name" ]]; then
            # Get the ref for this tag
            ref_data=$(curl_api "https://api.github.com/repos/$repo/git/refs/tags/$tag_name")
            latest_sha=$(echo "$ref_data" | jq -r '.object.sha')
            obj_type=$(echo "$ref_data" | jq -r '.object.type')
            
            # If it's an annotated tag, dereference to get commit SHA
            if [[ "$obj_type" == "tag" ]]; then
              echo "   (Dereferencing annotated tag...)"
              tag_data=$(curl_api "https://api.github.com/repos/$repo/git/tags/$latest_sha")
              latest_sha=$(echo "$tag_data" | jq -r '.object.sha')
            fi
          fi
          
          # Validate we got a SHA
          if [[ -z "$latest_sha" || "$latest_sha" == "null" ]]; then
            echo "   ‚ö†Ô∏è  Could not determine commit SHA, skipping"
            continue
          fi
          
          # Normalize tag (use "-" for no tag)
          [[ -z "$tag_name" || "$tag_name" == "null" ]] && tag_name="-"
          
          echo "   SHA: ${latest_sha}"
          [[ "$tag_name" != "-" ]] && echo "   Tag: ${tag_name}"
          echo "   Check type: ${actual_check_type}"
          
          # Store new state
          new_shas["$repo"]="$latest_sha"
          new_tags["$repo"]="$tag_name"
          new_check_types["$repo"]="$actual_check_type"
          
          # Check if this is an update
          current_sha="${current_shas[$repo]}"
          current_tag="${current_tags[$repo]:--}"
          current_check_type="${current_check_types[$repo]:-}"
          
          is_updated=false
          
          if [[ -z "$current_sha" ]]; then
            echo "   ‚ÑπÔ∏è  First time tracking this repository"
            is_updated=true
            has_changed=true
            if [[ "$tag_name" != "-" ]]; then
              commit_body+="- **$repo**: Added at \`$tag_name\` (\`$actual_check_type\`)\n"
            else
              commit_body+="- **$repo**: Added at \`${latest_sha:0:7}\` (\`$actual_check_type\`)\n"
            fi
          elif [[ "$actual_check_type" != "$current_check_type" ]]; then
            echo "   ‚úÖ UPDATE DETECTED (check_type changed: $current_check_type ‚Üí $actual_check_type)"
            is_updated=true
            has_changed=true
            if [[ "$tag_name" != "-" && "$current_tag" != "-" ]]; then
              commit_body+="- **$repo**: \`$current_tag\` (\`$current_check_type\`) ‚Üí \`$tag_name\` (\`$actual_check_type\`)\n"
            else
              commit_body+="- **$repo**: Check type changed \`$current_check_type\` ‚Üí \`$actual_check_type\`\n"
            fi
          elif [[ "$latest_sha" != "$current_sha" ]]; then
            echo "   ‚úÖ UPDATE DETECTED"
            is_updated=true
            has_changed=true
            
            # Format change message
            if [[ "$tag_name" != "-" && "$current_tag" != "-" ]]; then
              commit_body+="- **$repo**: \`$current_tag\` ‚Üí \`$tag_name\`\n"
            elif [[ "$tag_name" != "-" ]]; then
              commit_body+="- **$repo**: \`${current_sha:0:7}\` ‚Üí \`$tag_name\` (\`${latest_sha:0:7}\`)\n"
            else
              commit_body+="- **$repo**: \`${current_sha:0:7}\` ‚Üí \`${latest_sha:0:7}\`\n"
            fi
          else
            echo "   ‚úì Up to date"
          fi
          
          # Build JSON output
          if ! $first_result; then
            results_json+=","
          fi
          first_result=false
          
          # Properly escape JSON strings
          tag_json=$(echo -n "$tag_name" | jq -R -s '.')
          results_json+="{\"repo\":\"$repo\",\"sha\":\"$latest_sha\",\"tag\":$tag_json,\"check_type\":\"$actual_check_type\",\"is_updated\":$is_updated}"
          
        done
        
        results_json+="]"
        
        echo ""
        echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
        
        # Set action outputs
        {
          echo "results<<EOFOUTPUT"
          echo "$results_json"
          echo "EOFOUTPUT"
          echo "has_updates=$has_changed"
        } >> $GITHUB_OUTPUT
        
        # Handle state file writing and committing
        if [[ -n "$STATE_FILE" && ${#new_shas[@]} -gt 0 ]]; then
          echo ""
          echo "üìù Writing state to $STATE_FILE"
          
          # Write state file with header
          {
            echo "# Upstream dependency versions"
            echo "# Format: owner/repo sha tag_name check_type"
            echo "# Updated: $(date -u +"%Y-%m-%d %H:%M:%S UTC")"
            echo ""
            # Sort repos for consistent ordering
            for repo in $(printf '%s\n' "${!new_shas[@]}" | sort); do
              echo "$repo ${new_shas[$repo]} ${new_tags[$repo]} ${new_check_types[$repo]}"
            done
          } > "$STATE_FILE"
          
          # Commit if there were actual changes
          if [[ "$has_changed" == "true" ]]; then
            echo ""
            echo "üì§ Committing changes..."
            
            git config user.name "github-actions[bot]"
            git config user.email "41898282+github-actions[bot]@users.noreply.github.com"
            
            git add "$STATE_FILE"
            
            # Create commit with detailed body
            commit_msg="feat(deps): update upstream dependencies"
            commit_desc="### Updated Dependencies

$commit_body
---
*Updated via [${{ github.workflow }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})*"
            
            git commit -m "$commit_msg" -m "$(echo -e "$commit_desc")"
            
            # Push changes
            if [[ -n "$TOKEN" ]]; then
              git push "https://x-access-token:${TOKEN}@github.com/${{ github.repository }}.git" HEAD:${{ github.ref }}
            else
              git push
            fi
            
            echo "‚úÖ Successfully committed and pushed updates"
          else
            echo "‚ÑπÔ∏è  State file written but no changes detected"
          fi
        elif [[ "$has_changed" == "true" ]]; then
          echo ""
          echo "‚ÑπÔ∏è  Updates found but no state_file specified - skipping commit"
        else
          echo ""
          echo "‚úÖ All repositories are up to date"
        fi
        
        # Display summary table
        echo ""
        echo "=== üìä Results Summary ==="
        printf "  %-40s %-10s %-15s %-12s %s\n" "Repository" "SHA" "Tag" "Check Type" "Updated"
        printf "  %-40s %-10s %-15s %-12s %s\n" "----------------------------------------" "----------" "---------------" "------------" "-------"
        echo "$results_json" | jq -c '.[]' | while read -r item; do
          repo=$(echo "$item" | jq -r '.repo')
          sha=$(echo "$item" | jq -r '.sha')
          tag=$(echo "$item" | jq -r '.tag')
          check_type=$(echo "$item" | jq -r '.check_type')
          is_updated=$(echo "$item" | jq -r '.is_updated')
          
          update_indicator="  "
          [[ "$is_updated" == "true" ]] && update_indicator="‚úÖ"
          
          printf "  %-40s %-10s %-15s %-12s %s\n" "$repo" "${sha:0:7}" "$tag" "$check_type" "$update_indicator"
        done
